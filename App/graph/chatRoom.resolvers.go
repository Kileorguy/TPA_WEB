package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/Kileorguy/graph/model"
	"github.com/Kileorguy/middleware"
	"github.com/google/uuid"
)

// CreateChatRoom is the resolver for the createChatRoom field.
func (r *mutationResolver) CreateChatRoom(ctx context.Context, input *model.CreateChatRoom) (*model.ChatRoom, error) {
	ID := uuid.NewString()
	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)

	var res *model.ChatRoom
	err := r.DB.First(&res, "(user1_id = ? AND user2_id = ?) OR (user1_id = ? AND user2_id = ?)", email, input.User2id, input.User2id, email).Error
	if err == nil {
		fmt.Println("Dont Create ", err)
		return res, err
	} else {
		fmt.Println("Create ", err)
		chatRoom := &model.ChatRoom{
			ID:      ID,
			User1ID: email,
			User2ID: input.User2id,
		}
		r.DB.Create(chatRoom)
		return chatRoom, r.DB.Preload("User1").Preload("User2").First(&chatRoom, "ID = ?", ID).Error
	}
}

// GetChatRoom is the resolver for the getChatRoom field.
func (r *queryResolver) GetChatRoom(ctx context.Context, user string) ([]*model.ChatRoom, error) {
	var chatRooms []*model.ChatRoom
	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)
	fmt.Println("EMAILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL", email)
	return chatRooms, r.DB.Preload("User1").Preload("User2").Find(&chatRooms, "user1_id = ? OR user2_id = ?", email, email).Error
	panic(fmt.Errorf("not implemented: GetChatRoom - getChatRoom"))
}
