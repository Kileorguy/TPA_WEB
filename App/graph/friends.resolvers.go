package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/Kileorguy/graph/model"
	"github.com/Kileorguy/middleware"
)

// CreateFriends is the resolver for the createFriends field.
func (r *mutationResolver) CreateFriends(ctx context.Context, input string) (*model.Friends, error) {
	token := ctx.Value("Email").(string)
	email, _ := middleware.JWT_decrypt(token)
	friend := &model.Friends{
		SenderID:   email,
		ReceiverID: input,
		Accepted:   false,
	}

	_, _ = r.CreateNotificationID(ctx, email+" Request to be Friends", input)

	r.DB.Create(&friend)

	err := r.DB.Preload("Sender").Preload("Receiver").First(&friend, "sender_id = ?", email).Error
	return friend, err
}

// AcceptFriendRequest is the resolver for the acceptFriendRequest field.
func (r *mutationResolver) AcceptFriendRequest(ctx context.Context, senderID string) (*bool, error) {
	token := ctx.Value("Email").(string)
	email, _ := middleware.JWT_decrypt(token)

	var friends *model.Friends

	if err := r.DB.First(&friends, "sender_id = ? AND receiver_id = ?", senderID, email).Error; err != nil {
		return nil, err
	}
	friends.Accepted = true
	_, _ = r.CreateNotificationID(ctx, email+" Accepted your friend request", senderID)

	return nil, r.DB.Save(&friends).Error
}

// GetFriend is the resolver for the getFriend field.
func (r *queryResolver) GetFriend(ctx context.Context, input string) ([]*model.User, error) {
	token := ctx.Value("Email").(string)
	email, _ := middleware.JWT_decrypt(token)
	var friends []string

	err := r.DB.Model(&model.Friends{}).Where("(sender_id = ? OR receiver_id = ?) AND accepted = ?", email, email, true).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", email).Find(&friends).Error

	if err != nil {
		return nil, err
	}
	var friendsModel []*model.User
	err1 := r.DB.Find(&friendsModel, "email in (?)", friends).Error
	return friendsModel, err1
}

// GetFriendRequest is the resolver for the getFriendRequest field.
func (r *queryResolver) GetFriendRequest(ctx context.Context, input string) ([]*model.User, error) {
	token := ctx.Value("Email").(string)
	email, _ := middleware.JWT_decrypt(token)
	var friends []string
	fmt.Println(email)
	err := r.DB.Model(&model.Friends{}).Where("(receiver_id = ?) AND accepted = ?", email, false).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", email).Find(&friends).Error
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	fmt.Println(len(friends))
	var friendsModel []*model.User
	fmt.Println(len(friendsModel))
	return friendsModel, r.DB.Find(&friendsModel, "email in (?)", friends).Error
}

// GetMightKnow is the resolver for the getMightKnow field.
func (r *queryResolver) GetMightKnow(ctx context.Context, input string) ([]*model.User, error) {
	var inputUser *model.User

	r.DB.Find(&inputUser, "id = ?", input)

	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)
	var friends []string

	err := r.DB.Model(&model.Friends{}).
		Where("(sender_id = ? OR receiver_id = ?) AND (sender_id != ? AND receiver_id != ?) AND accepted = true", inputUser.Email, inputUser.Email, email, email).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", inputUser.Email).Limit(5).Find(&friends).Error

	if err != nil {
		return nil, err
	}

	var myFriends []string

	err = r.DB.Model(&model.Friends{}).Where("(sender_id = ? OR receiver_id = ?) AND accepted = ?", email, email, true).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", email).Find(&myFriends).Error

	var friendsModel []*model.User
	err1 := r.DB.Find(&friendsModel, "email in (?) AND email not in (?)", friends, myFriends).Error
	return friendsModel, err1

	panic(fmt.Errorf("not implemented: GetMightKnow - getMightKnow"))
}

// GetFriendsMightKnow is the resolver for the getFriendsMightKnow field.
func (r *queryResolver) GetFriendsMightKnow(ctx context.Context) ([]*model.User, error) {
	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)
	var currFriend []string

	err := r.DB.Model(&model.Friends{}).Where("(sender_id = ? OR receiver_id = ?) AND accepted = ?", email, email, true).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", email).Find(&currFriend).Error
	var friends []string

	err = r.DB.Model(&model.Friends{}).
		Where("(sender_id IN (?) OR receiver_id IN (?)) AND (sender_id NOT IN (?) AND receiver_id NOT IN (?)) AND accepted = true", currFriend, currFriend, email, email).
		Select("CASE WHEN sender_id IN (?) THEN receiver_id ELSE sender_id END", currFriend).Limit(5).Find(&friends).Error

	if err != nil {
		return nil, err
	}

	var myFriends []string

	err = r.DB.Model(&model.Friends{}).Where("(sender_id = ? OR receiver_id = ?) AND accepted = ?", email, email, true).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", email).Find(&myFriends).Error

	var friendsModel []*model.User
	err1 := r.DB.Find(&friendsModel, "email in (?) AND email not in (?)", friends, myFriends).Error
	return friendsModel, err1

	panic(fmt.Errorf("not implemented: GetMightKnow - getMightKnow"))
}
