package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/Kileorguy/graph/model"
	"github.com/Kileorguy/middleware"
)

// AddPostLike is the resolver for the addPostLike field.
func (r *mutationResolver) AddPostLike(ctx context.Context, postID string, userID string) (*model.PostLike, error) {
	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)

	postLike := &model.PostLike{

		UserID: email,
		PostID: postID,
	}
	//r.DB.Save(&postLike)

	//err := r.DB.Delete(&postLike, "post_id = ? AND user_id = ?", postID, email).Error
	//if err == nil {
	//	print("DELETE")
	//	return nil, err
	//}
	err := r.DB.Create(&postLike).Error
	if err != nil {
		fmt.Println("Delete")
		r.DB.Delete(&postLike, "post_id = ? AND user_id = ?", postID, email)
		return nil, nil
	}
	err1 := r.DB.Preload("User").Preload("Post").First(&postLike, "post_id = ?", postID).Error
	_, _ = r.CreateNotificationID(ctx, email+" Likes your post", postLike.UserID)
	return postLike, err1
	//panic(fmt.Errorf("not implemented: AddPostLike - addPostLike"))
}

// AddReelsLike is the resolver for the addReelsLike field.
func (r *mutationResolver) AddReelsLike(ctx context.Context, reelsID string, userID string) (*model.ReelsLike, error) {
	token := ctx.Value("token").(string)
	email, _ := middleware.JWT_decrypt(token)

	reelsLike := &model.ReelsLike{
		ReelsID: reelsID,
		UserID:  email,
	}
	fmt.Println(reelsLike)
	err := r.DB.Create(&reelsLike).Error
	if err != nil {
		print("Delete")
		r.DB.Delete(&reelsLike, "reels_id = ? AND user_id = ?", reelsID, email)
		return nil, nil
	}
	err1 := r.DB.Preload("User").Preload("Reels").First(&reelsLike).Error
	_, _ = r.CreateNotificationID(ctx, email+" Likes your reels", reelsLike.UserID)
	return reelsLike, err1

	panic(fmt.Errorf("not implemented: AddReelsLike - addReelsLike"))
}

// GetPostLikes is the resolver for the getPostLikes field.
func (r *queryResolver) GetPostLikes(ctx context.Context, input string) ([]*model.PostLike, error) {
	var postLikes []*model.PostLike
	return postLikes, r.DB.Preload("User").Find(&postLikes, "post_id = ?", input).Error
}

// GetReelsLikes is the resolver for the getReelsLikes field.
func (r *queryResolver) GetReelsLikes(ctx context.Context, input string) ([]*model.ReelsLike, error) {
	panic(fmt.Errorf("not implemented: GetReelsLikes - getReelsLikes"))
}

// User is the resolver for the User field.
func (r *postLikeResolver) User(ctx context.Context, obj *model.PostLike) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: User - User"))
}

// User is the resolver for the User field.
func (r *reelsLikeResolver) User(ctx context.Context, obj *model.ReelsLike) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: User - User"))
}

// PostLike returns PostLikeResolver implementation.
func (r *Resolver) PostLike() PostLikeResolver { return &postLikeResolver{r} }

// ReelsLike returns ReelsLikeResolver implementation.
func (r *Resolver) ReelsLike() ReelsLikeResolver { return &reelsLikeResolver{r} }

type postLikeResolver struct{ *Resolver }
type reelsLikeResolver struct{ *Resolver }
