package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Kileorguy/graph/model"
	"github.com/Kileorguy/helper"
	"github.com/Kileorguy/middleware"
	"github.com/Kileorguy/service"
	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	//panic(fmt.Errorf("not implemented: CreateUser - createUser"))
	pw := helper.HashAndSalt(input.Password)
	user := &model.User{
		ID:        uuid.NewString(),
		FirstName: input.FirstName,
		Surname:   input.Surname,
		Email:     input.Email,
		Dob:       input.Dob,
		Gender:    input.Gender,
		Password:  pw,
		Role:      input.Role,
		Active:    false,
	}
	return user, r.DB.Save(&user).Error
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input string, updated model.NewUser) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// ActivateUser is the resolver for the activateUser field.
func (r *mutationResolver) ActivateUser(ctx context.Context, email string) (*model.User, error) {
	var user *model.User

	if err := r.DB.First(&user, "email = ?", email).Error; err != nil {
		return nil, err
	}
	user.Active = true
	return user, r.DB.Save(&user).Error
}

// AddOrUpdateProfile is the resolver for the addOrUpdateProfile field.
func (r *mutationResolver) AddOrUpdateProfile(ctx context.Context, link string, email string) (*model.User, error) {
	var user *model.User
	redisUser, err := r.Redis.Get(ctx, fmt.Sprintf(`user:%s`, email)).Result()
	if err != nil {
		if err := r.DB.First(&user, "email = ?", email).Error; err != nil {
			return nil, err
		}
	} else {
		err = json.Unmarshal([]byte(redisUser), &user)
		if err != nil {
			return nil, err
		}
		fmt.Println("UNMARSHAL REDISSSSSSSSSSSSSSSSSSSSS")
	}
	user.ProfilePicture = link
	return user, r.DB.Save(&user).Error
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context) ([]*model.User, error) {
	var users []*model.User
	return users, r.DB.Find(&users).Error
}

// GetUserSearch is the resolver for the getUserSearch field.
func (r *queryResolver) GetUserSearch(ctx context.Context, input string) ([]*model.User, error) {
	var user []*model.User
	input = "%" + input + "%"
	return user, r.DB.Where("first_name LIKE ? OR surname LIKE ?", input, input).Find(&user).Error
}

// GetUserbyEmail is the resolver for the getUserbyEmail field.
func (r *queryResolver) GetUserbyEmail(ctx context.Context, token string) (*model.User, error) {
	fmt.Println("Tokenn", token)
	email, _ := middleware.JWT_decrypt(token)
	fmt.Println("email", email)
	return service.GetUserbyEmail(email)
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, email string, password string) (string, error) {
	user, err := service.GetUserbyEmail(email)
	if err != nil {
		return "", err
	}
	fmt.Printf("TokenInLogin :%s %s\n", user.Password, password)
	if helper.ValidateSaltPassword(password, user.Password) {
		tokens, err := middleware.JWT_encrypt(user.Email)
		if userRedis, err := json.Marshal(user); err == nil {
			fmt.Println("MARSHAL REDISSSSSSSSSSSSSSSSSSSSS")

			r.Redis.Set(ctx, fmt.Sprintf(`user:%s`, email), userRedis, 2*60*time.Minute)
		}
		return tokens, err
	} else {
		return "", nil
	}
}

// ValidateToken is the resolver for the validateToken field.
func (r *queryResolver) ValidateToken(ctx context.Context, token string) (bool, error) {
	email, _ := middleware.JWT_decrypt(token)
	data, err := service.GetUserbyEmail(email)

	if err != nil || data.Active == false {
		return false, nil
	} else {
		return true, nil
	}
}

// GetUserByID is the resolver for the getUserByID field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	var user *model.User
	return user, r.DB.First(&user, "id = ?", id).Error
	panic(fmt.Errorf("not implemented: GetUserByID - getUserByID"))
}

// Friends is the resolver for the Friends field.
func (r *userResolver) Friends(ctx context.Context, obj *model.User) ([]*model.User, error) {
	var friends []string
	fmt.Println(obj.Email)
	//return nil, nil
	//
	err := r.DB.Model(&model.Friends{}).Where("(sender_id = ? OR receiver_id = ?) AND accepted = ?", obj.Email, obj.Email, true).
		Select("CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", obj.Email).Find(&friends).Error

	if err != nil {
		return nil, err
	}
	var friendsModel []*model.User
	err1 := r.DB.Find(&friendsModel, "email in (?)", friends).Error
	return friendsModel, err1

	panic(fmt.Errorf("not implemented: Friends - Friends"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
